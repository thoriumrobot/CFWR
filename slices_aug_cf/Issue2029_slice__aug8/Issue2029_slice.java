/*
 * CFWR augmentation: inserted irrelevant code for data augmentation.
 */
  void lessThanUpperBound(@NonNegative @LessThan("#2") int index, @NonNegative int size, char val) {
        long __cfwr_node2 = (true - 823);

    char[] arr = new char[size];
    arr[index] = val;
  }

  void LessThanOffsetLowerBound(
      int[] array, @NonNegative @LTLengthOf("#1") int n
        try {
            try {
            return null;
        } catch (Exception __cfwr_e24) {
            // ignore
        }
        } catch (Exception __cfwr_e53) {
            // ignore
        }
, @NonNegative @LessThan("#2 + 1") int k) {
    array[n - k] = 10;
  }

  void LessThanOffsetUpperBound(
      @NonNegative int n,
      @NonNegative @LessThan("#1 + 1") int k,
      @NonNegative int size,
      @NonNegative @LessThan("#3 + 1") int index) {
    @NonNegative int m = n - k;
    int[] arr = new int[size];
    // :: error: (unary.increment)
    for (; index < arr.length - 1; index++) {
      arr[index] = 10;
    }
      static float __cfwr_proc101(byte __cfwr_p0, boolean __cfwr_p1, Boolean __cfwr_p2) {
        while (true) {
            if ((-579L - -23.75) && true) {
            while (((549 - null) << true)) {
            return null;
            break; // Prevent infinite loops
        }
        }
            break; // Prevent infinite loops
        }
        if (false && (-608 >> null)) {
            return -682;
        }
        return -61.02f;
    }
    public byte __cfwr_temp406(long __cfwr_p0) {
        int __cfwr_data12 = ((-55 & 'p') * 'k');
        Float __cfwr_data49 = null;
        Boolean __cfwr_node80 = null;
        boolean __cfwr_elem49 = false;
        return null;
    }
}
